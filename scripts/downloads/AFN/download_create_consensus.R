library(tidyverse)

# Read Allele Frequency Net data
# (RDS file generated by scripts/downloads/AFN/download.R)
afn_frequencies = readRDS("downloads/AFN/hla_allele_frequencies.rds")

mhc1_genes = c("A", "B", "C")
mhc2_genes = c("DPA1", "DPB1", "DQA1", "DQB1", "DRB1")

# Determine which datasets have reliable information for each of the genes, per ethnicity
# For DPA1: no information for Americans. For Caucasian Americans we can infer information from European populations.
# For DPB1: information for African-Americans is available. For Caucasian Americans only sequencing based frequencies are present.
# For DQ- and DRB1: we can directly look at the US population
gold_datasets = afn_frequencies %>%
  # Exclude the following populations
  filter(
    # Frequencies of Liberian population do not correlate well with US African American population
    population != "Liberia Bong County",
    # USA San Francisco HLA Calls were based on NGS data, not a PCR-based method
    population != "USA San Francisco Caucasian"
    ) %>%
  
  group_by(`Ethnic origin`) %>%
  group_modify(function(df, key) {
    # For the current ethnic origin,
    # list per gene the populations with "gold" quality label
    df %>%
      # Format data to a nested list: ethnicity -> gene -> dataset
      rename_with( ~ str_remove(., "^quality_")) %>%
      select(population_id, `Geographic Region`, !!!c(mhc1_genes, mhc2_genes)) %>%
      gather("gene", "quality",-population_id,-`Geographic Region`) %>%
      # Only select gold quality population information
      filter(quality == "gold") %>%
      select(-quality) %>%
      # Force Geographic Region == North America, unless for DPA1 and DPB1 where we have no better data
      filter(`Geographic Region` == "North America" | gene %in% c("DPA1", "DPB1")) %>%
      group_by(gene) %>%
      summarise(population_id=list(population_id), .groups = "drop")
  }) %>%
  # Unnest populations
  unnest(population_id) %>%
  # Prefer population 2780 (USA population 5) for Caucasoid, DPB1
  filter(!((`Ethnic origin` == "Caucasoid") & (gene == "DPB1")) | population_id == 2780)

# Manual exclusions:
# For DRB1, USA Caucasian Bethesda the allele frequencies sum to 0.127
# See: http://allelefrequencies.net/hla6006a.asp?hla_population=1619
# The San Anatonio dataset (sums to 0.807) looks better

# Stack all frequencies in one table
stacked = afn_frequencies %>%
  select(population_id, hla_frequencies) %>%
  unnest(hla_frequencies) %>%
  # Only keep information for alleles at 4 digit level
  filter(resolution == 4) %>%
  # Remove trailing letters in the allele name
  mutate(allele=str_replace(allele, "([0-9]+:[0-9]+).*$", "\\1")) %>%
  select(population_id, gene, allele, frequency, sample_size)

# Map frequencies (stacked data frame) to G-groups per dataset before aggregation
# Reason: Most datasets use sequence specific primers that are limited to G-group resolution
# It is non-sensical to leave the other datasets at higher resolution.
# TODO: g_groups.rds is created by "create_ggroup_mapping.R" in the mhc2_genotyping project
# copy this script to the downloads folder and make it independent of the project
mapping = readRDS("/home/arne/projects/mhc2_genotyping/data/ggroup_mapping.rds") %>%
  select(allele, group) %>%
  deframe

ga_map <- function(gene, allele) {
  gene_allele = paste0(gene, '*', allele)
  
  # Return allele itself if no G-group was defined
  if_else(gene_allele %in% names(mapping), str_remove(mapping[gene_allele], '^[^*]*\\*'), allele)
}

allele_col_map <- function(x) {
  gene_idx = simplify2array(str_split(cur_column(), "\\."))
  gene = gene_idx[[1,1]]
  ga_map(gene, x)
}

allele_map <- function(prediction) {
  mutate(prediction, across(-sample_id, allele_col_map))
}

# Note: in R sum(c(NA,NA), na.rm=T)
# This is not the behaviour we want.
# If all frequencies of the alleles that comprise a particular G group are NA -> NA for G-group
# If k < n of the alleles in a G group is NA -> sum, while ignoring the k NAs
sum.freqs <- function(x) {
  if(all(is.na(x))) {
    return(NA)
  } else {
    return(sum(x, na.rm = T))
  }
}

stacked = stacked %>%
  mutate(allele = ga_map(gene, allele)) %>%
  # group by population, (gene, allele)
  # population and sample_size also added: unique per population_id and columns needed later
  group_by(population_id, population, sample_size, gene, allele) %>%
  summarise(frequency=sum.freqs(frequency)) %>%
  ungroup

# Calculate consensus frequency over gold populations
# Add frequency information to the list of reliable datasets

# We perform an inner join:
# (NA for right join would mean: data exists for that gene and that population, but it is not listed as a gold dataset)
# => we do not want to include this
 
# NA for left join: for that dataset a particular gene was not found even though it was reported as "gold"
# (This is the case for dataset 1620)
# => This is an error in the metadata
# Remaining NAs mean that allele was not tested for in that population.
# We want to keep these NAs
consensus = inner_join(gold_datasets, stacked, by=c("gene","population_id")) %>%
  group_by(`Ethnic origin`, gene, allele) %>%
  # Average the frequency over all reliable datasets, weighted according to the sample size
  # Ignore datasets where that allele is NA
  summarise(frequency=weighted.mean(frequency, as.numeric(sample_size), na.rm=T)) %>%
  ungroup %>%
  spread(`Ethnic origin`, frequency) %>%
  rename("African American"="Black", "Caucasian American"="Caucasoid")

# Note: weighted.mean(c(NA,NA), na.rm=T) -> NaN
# But: sum(c(NA,NA), na.rm=T) -> 0

# Note that no information is available about DPA1 in the African American population
# For DQA1: the total allele frequency = 0.704 for African American
saveRDS(consensus, "/home/labgroups/ccgg/downloads/AFN/consensus_ggroup.rds")
